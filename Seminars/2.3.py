




# Чтобы посмотреть что может функция, которую мы хотим использовать пишем:
# dir(list) - где в скобках указываем нужную функцию

# print(dir(list))

# И внизу то что без нижних подчёркиваний - это те действия, которые мы можем использовать с этой функцией.
# append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort

# n = [1, 2, False]
# n.append(4) # добавление в конец списка
# n.insert(2, True) # по второму индексу добавляем true
# # при insert на определённую позицию, то значение, которое стояло на той позиции сместится , а не будет заменено новым значением
# # эта операция очень "энергоёмкая" , если список большой, то переставлять все значения будет очень ресурсоёмко

# n.append([10,33]) # - если мы хотим через append добавить список, то он добавит то что в () скобках // [10,33]
# n.extend([10,22])   # - а если через extend, то добавиться именно список ("распакованный")  // 10, 22

# n.count(11) # то count не увидит число 11, которое в коробке - []
# pop - удаление по индексу
# remove - удаляет по значению
# reverse - разворот
# sort - сортировка

# print(n)


# Выше была информация по работе со списками


# print(dir(str))

# 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 
# 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 
# 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 
# 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'removeprefix', 
# 'removesuffix', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 
# 'split', 
# 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'

# Ключевые методы:

# split 
# 
# - пользователь вводит значение "1  4  2" и мы просим убрать пробелы из этой строки
# "1 4 2".split(" ") - и получаем ['1', '4', '2'] список без пробелов 
# split уберёт только один пробел между между числами. И если пользователь ввёл:
# "1          4     2" , то у нас будет такая конструкция: 
# ['1', '', '', '', '', '', '', '4', '', '', '', '2']
# в таком случае просто пишем split() и он убирает все пробелы, переходы на следующую строку - все зарезервированные конструкции
# Так же работает с запятыми, точками...

# join
#
# - склейка
# " ".join(["Name", "Surname"]) - "конкретинация" будет у нас пробелом " ", и после join пишем  список СТРОКОВЫХ элементов - не строковых сломается.

# print( " ".join(["Name", "Surname"]) )

# print( " & ".join(["Name", "Surname"]) )


# isdigit - проверяем является ли числом - при том не работает с дробными и с отрецательными числами
# print("jdddsa".isdigit()) # // False
# print("123".isdigit())  # // True
# print("-123.9".isdigit())  # // False
# print("-123".replace("-", "").isdigit())  # // True
# print("Gipopotampo".replace("po","pa"))
# print("Gipopotampo".replace("po","")) # просто склеиваем результат
# print("Gipopotampo".count("po")) # - считает сколько "ро"

# регистр
# print("сЕрГеЙ".title()) # - // Сергей
# print("сЕрГеЙ".capitalize()) # - // Сергей

# print("сЕрГеЙ ЕрГеЙ".title()) # - // Сергей Сергей
# print("сЕрГеЙ ЕрГеЙ".capitalize()) # - // Сергей сергей



# Задача 3

# Написать программу, в которой пользователь будет задавать две строки,
# программа - определять кол-во вхождений одной строки в другую

# inserted_string = input("Введите строку: ")
# string_to_find = input("Введите фрагмент, который нужно найти: ")
# print("Количество", string_to_find, "в строке", inserted_string, "равняется: ", inserted_string.count(string_to_find)) 




# Преобразование дроби в целое число
m = len("0.123456")
# print(0.123456*10**m) # в длинне считается "." в том числе
print(0.123456*10**(m-2))
print(99999999.123456*10**(m-2)) # тоже будет корректно

# и можно уже конвертировать из дробное в целое
print(int(99999999123456.0))